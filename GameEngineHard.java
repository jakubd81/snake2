package com.example.jakub.snake2;import android.graphics.Canvas;import android.support.annotation.Nullable;import java.util.ArrayList;import java.util.Iterator;import java.util.List;/** * Created by Jakub on 21.12.2015. */public class GameEngineHard extends GameEngineBase{    @Nullable    private final Food m_segmentRemover;    @Nullable    private final List<DetachedSegment> m_detachedSegments;    @Nullable    private final IEngineHardSettings m_hardSettings;    public GameEngineHard(IVelocitySettings velocitySettings, IScoreHandlerSettings scoreHandlerSettings, IEngineHardSettings hardSettings)    {        super(velocitySettings, scoreHandlerSettings);        m_hardSettings = hardSettings;        AnimationResource removerGfx = ResourceManager.getInstance().getAnimationResource("remover_animated");        ArrayList<AnimationResource> removerResources = new ArrayList<>();        removerResources.add(removerGfx);        AnimationHandlerBase removerAnimationHandler = new AnimationHandlerBase(removerResources, IFrameAnimationHandler.FIRST_FRAME);        m_segmentRemover = new Food(removerAnimationHandler, Food.GENERATE_TRIALS, 0, 0, Field.Direction.NO_DIRECTION);        m_detachedSegments = new ArrayList<>();        m_drawables.add(m_segmentRemover);    }    @Override    public void draw(Canvas canvas)    {        super.draw(canvas);        drawDetachedSegments(canvas);    }    @Override    public boolean update(Field.Direction selectedDirection)    {        boolean gameOver = false;        if ((null != m_snake) && (null != m_scoreHandler) && (null != m_velocitySettings) && (null != m_hardSettings))        {            m_stepCounter++;            moveSnake();            if (m_velocitySettings.getFirstStep()== m_stepCounter)            {                boolean collision = checkCollisions();                if (collision)                {                    ResourceManager.getInstance().playAudioSample("game_over");                    gameOver = true;                }            }            else if (m_velocitySettings.getLastStep() == m_stepCounter)            {                updateFood();                updateSegmentRemover();                removeDetachedSegments();                updatePlayerInput(selectedDirection);                updateBreakingPoints();                m_stepCounter = 0;            }            m_scoreHandler.update(m_hardSettings.getScoreReduction());        }        else        {            System.out.println("ERROR: GameEngineHard::updateBoard()");        }        return gameOver;    }    @Override    protected void updateFood()    {        if ((null != m_food) && (null != m_snake) && (null != m_scoreHandler))        {            if (!m_food.isGenerated())            {                boolean noSnakeCollision = generateNewFood();                boolean removerCollision = true;                for (short i = 0; (i < m_food.getGenerateTrials()) && removerCollision; i++)                {                    removerCollision = removerAndFoodCollision();                }                if (noSnakeCollision && !removerCollision)                {                    m_scoreHandler.setNewScoreCounter(m_snake.getHeadXposition(), m_snake.getHeadYposition(), m_food.getXposition(), m_food.getYposition());                    m_food.setGenerated(true);                }            }            else            {                boolean foodEaten = m_snake.isFoodEaten(m_food.getXposition(), m_food.getYposition());                if (foodEaten)                {                    m_scoreHandler.addScores();                    m_snake.addBodySegment();                    ResourceManager.getInstance().playAudioSample("food_eaten");                    m_food.setGenerated(false);                }            }        }        else        {            System.out.println("ERROR: GameEngineHard::updateFood()");        }    }    private void drawDetachedSegments(Canvas canvas)    {        if (null != m_detachedSegments)        {            Iterator<DetachedSegment> it = m_detachedSegments.iterator();            DetachedSegment detachedSegment;            while (it.hasNext())            {                detachedSegment = it.next();                detachedSegment.draw(canvas);            }        }    }    private void updateSegmentRemover()    {        if ((null != m_segmentRemover) && (null != m_snake) && (null != m_scoreHandler))        {            if (!m_segmentRemover.isGenerated())            {                generateNewRemover();            }            else            {                boolean removerEaten = m_snake.isFoodEaten(m_segmentRemover.getXposition(), m_segmentRemover.getYposition());                if (removerEaten)                {                    m_segmentRemover.setGenerated(false);                    handleDetachedSegment();                }            }        }        else        {            System.out.println("ERROR: GameEngineHard::updateSegmentRemover()");        }    }    private void handleDetachedSegment()    {        if ((null != m_snake) && (null != m_detachedSegments))        {            boolean detachSnake = m_snake.checkIfDetachSegments();            if (detachSnake)            {                List<DetachedSegment> detachedSegments = m_snake.removeSegments(); //todo tryc catch                if (null != detachedSegments)                {                    m_detachedSegments.addAll(detachedSegments);                    ResourceManager.getInstance().playAudioSample("remover_eaten");                }            }            else            {                // segment isn't detached due to snake is too short                ResourceManager.getInstance().playAudioSample("remover_fail");            }        }    }    // remove used detached segments    private void removeDetachedSegments()    {        if (null != m_detachedSegments)        {            DetachedSegment detachedSegment;            boolean segmentActive;            Iterator<DetachedSegment> it = m_detachedSegments.iterator();            while (it.hasNext())            {                detachedSegment = it.next();                segmentActive = detachedSegment.isActive();                if (!segmentActive)                {                    it.remove();                }            }        }    }    private void generateNewRemover()    {        boolean generateRemover = checkIfGenerateRemover();        if (generateRemover && (null != m_snake) && (null != m_segmentRemover) && (null != m_scoreHandler) && (null != m_food))        {            try            {                List<SnakeSegment> snakeBody = m_snake.getSnakeBody();                boolean noSnakeCollision = false;                boolean removerFoodCollision = true;                if ((null != snakeBody) && (snakeBody.size() > 0))                {                    for (short i = 0; (m_food.getGenerateTrials() > i) && !noSnakeCollision; i++)                    {                        m_segmentRemover.generate();                        noSnakeCollision = m_segmentRemover.noSnakeCollision(snakeBody);                    }                    for (short i = 0; (m_food.getGenerateTrials() > i) && removerFoodCollision; i++)                    {                        removerFoodCollision = removerAndFoodCollision();                    }                }                if (noSnakeCollision && !removerFoodCollision)                {                    m_segmentRemover.setGenerated(true);                    ResourceManager.getInstance().playAudioSample("remover_generated");                }            }            catch (NullPointerException e)            {                System.out.println("ERROR: GameEngineHard::generateNewRemover() NullPointerException: " + e.getMessage());            }        }    }    private boolean checkIfGenerateRemover()    {        boolean generate = false;        if ((null != m_segmentRemover) && (null != m_hardSettings))        {            int removerProbability = m_segmentRemover.generateRandomNumber(m_hardSettings.getMinProbabilityRange(), m_hardSettings.getMaxProbabilityRange());            if (removerProbability < m_hardSettings.getProbabilityThreshold())            {                generate = true;            }        }        else        {            System.out.println("ERROR: GameEngineHard::checkIfGenerateRemover()");        }        return generate;    }    private boolean removerAndFoodCollision()    {        boolean collision = true;        if ((null != m_segmentRemover) && (null != m_food))        {            collision = ((m_segmentRemover.getXposition() == m_food.getXposition()) && (m_segmentRemover.getYposition() == m_food.getYposition()));        }        else        {            System.out.println("ERROR: GameEngineHard::removerAndFoodCollision()");        }        return collision;    }}